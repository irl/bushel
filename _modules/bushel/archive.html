
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>bushel.archive &#8212; bushel 0.0.0a documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for bushel.archive</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Persistent filesystem-backed archive for Tor directory protocol</span>
<span class="sd">descriptors. This is intended to be used as part of an :py:mod:`asyncio`</span>
<span class="sd">application. File I/O operations are provided by coroutines and coroutine</span>
<span class="sd">methods, with the actual I/O performed in an executor.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>

<span class="kn">import</span> <span class="nn">aiofiles</span>

<span class="kn">from</span> <span class="nn">stem.descriptor</span> <span class="k">import</span> <span class="n">Descriptor</span>
<span class="kn">from</span> <span class="nn">stem.descriptor</span> <span class="k">import</span> <span class="n">DocumentHandler</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.extrainfo_descriptor</span> <span class="k">import</span> <span class="n">BridgeExtraInfoDescriptor</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.extrainfo_descriptor</span> <span class="k">import</span> <span class="n">RelayExtraInfoDescriptor</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.microdescriptor</span> <span class="k">import</span> <span class="n">Microdescriptor</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.networkstatus</span> <span class="k">import</span> <span class="n">NetworkStatusDocumentV3</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.server_descriptor</span> <span class="k">import</span> <span class="n">BridgeDescriptor</span>
<span class="kn">from</span> <span class="nn">stem.descriptor.server_descriptor</span> <span class="k">import</span> <span class="n">RelayDescriptor</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;bushel&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="CollectorOutSubdirectory"><a class="viewcode-back" href="../../archive.html#bushel.archive.CollectorOutSubdirectory">[docs]</a><span class="k">class</span> <span class="nc">CollectorOutSubdirectory</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration of subdirectory names under the &quot;out&quot; directory as specified in</span>
<span class="sd">    §5.0 of [collector-protocol]_.</span>

<span class="sd">    ======================= ===========</span>
<span class="sd">    Name                    Description</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    BRIDGE_DESCRIPTORS      Bridge descriptors (§5.2)</span>
<span class="sd">    EXIT_LISTS              Exit lists (§5.1)</span>
<span class="sd">    RELAY_DESCRIPTORS       Relay descriptors (§5.3)</span>
<span class="sd">    TORPERF                 Torperf and Onionperf (§5.1)</span>
<span class="sd">    WEBSTATS                Web server access logs (§5.4)</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BRIDGE_DESCRIPTORS</span> <span class="o">=</span> <span class="s1">&#39;bridge-descriptors&#39;</span>
    <span class="n">EXIT_LISTS</span> <span class="o">=</span> <span class="s1">&#39;exit-lists&#39;</span>
    <span class="n">RELAY_DESCRIPTORS</span> <span class="o">=</span> <span class="s1">&#39;relay-descriptors&#39;</span>
    <span class="n">TORPERF</span> <span class="o">=</span> <span class="s1">&#39;torperf&#39;</span>
    <span class="n">WEBSTATS</span> <span class="o">=</span> <span class="s1">&#39;webstats&#39;</span></div>


<div class="viewcode-block" id="CollectorOutRelayDescsMarker"><a class="viewcode-back" href="../../archive.html#bushel.archive.CollectorOutRelayDescsMarker">[docs]</a><span class="k">class</span> <span class="nc">CollectorOutRelayDescsMarker</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration of marker names under the &quot;relay-descriptors&quot; directory as</span>
<span class="sd">    specified in §5.3 of [collector-protocol]_.</span>

<span class="sd">    ======================= ===========</span>
<span class="sd">    Name                    Description</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    CONSENSUS               Network status consensuses (§5.3.2)</span>
<span class="sd">    EXTRA_INFO              Relay extra-info descriptors (§5.3.2)</span>
<span class="sd">    SERVER_DESCRIPTOR       Relay server descriptors (§5.3.2)</span>
<span class="sd">    VOTE                    Network status votes (§5.3.2)</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CONSENSUS</span> <span class="o">=</span> <span class="s1">&#39;consensus&#39;</span>
    <span class="n">EXTRA_INFO</span> <span class="o">=</span> <span class="s1">&#39;extra-info&#39;</span>
    <span class="n">MICRODESC</span> <span class="o">=</span> <span class="s1">&#39;microdesc&#39;</span>
    <span class="n">SERVER_DESCRIPTOR</span> <span class="o">=</span> <span class="s1">&#39;server-descriptor&#39;</span>
    <span class="n">VOTE</span> <span class="o">=</span> <span class="s1">&#39;vote&#39;</span></div>


<div class="viewcode-block" id="CollectorOutBridgeDescsMarker"><a class="viewcode-back" href="../../archive.html#bushel.archive.CollectorOutBridgeDescsMarker">[docs]</a><span class="k">class</span> <span class="nc">CollectorOutBridgeDescsMarker</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration of marker names under the &quot;bridge-descriptors&quot; directory as</span>
<span class="sd">    specified in §5.2 of [collector-protocol]_.</span>

<span class="sd">    ======================= ===========</span>
<span class="sd">    Name                    Description</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    EXTRA_INFO              Bridge extra-info descriptors (§5.2.1)</span>
<span class="sd">    SERVER_DESCRIPTOR       Bridge server descriptors (§5.2.1)</span>
<span class="sd">    STATUS                  Bridge statuses (§5.2.2)</span>
<span class="sd">    ======================= ===========</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EXTRA_INFO</span> <span class="o">=</span> <span class="s1">&#39;extra-info&#39;</span>
    <span class="n">SERVER_DESCRIPTOR</span> <span class="o">=</span> <span class="s1">&#39;server-descriptor&#39;</span>
    <span class="n">STATUSES</span> <span class="o">=</span> <span class="s1">&#39;statuses&#39;</span></div>


<div class="viewcode-block" id="parse_file"><a class="viewcode-back" href="../../archive.html#bushel.archive.parse_file">[docs]</a><span class="k">async</span> <span class="k">def</span> <span class="nf">parse_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses a descriptor from a file.</span>

<span class="sd">    :param content str/bytes: String to construct the descriptor from</span>
<span class="sd">    :param kwargs dict: Additional arguments for</span>
<span class="sd">                          :meth:`stem.descriptor.Descriptor.parse_file`.</span>
<span class="sd">    :returns: :class:`stem.descriptor.Descriptor` subclass for the given</span>
<span class="sd">              content, or a *list* of descriptors if **multiple=True** is</span>
<span class="sd">              provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiofiles</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">source</span><span class="p">:</span>
            <span class="n">raw_content</span> <span class="o">=</span> <span class="k">await</span> <span class="n">source</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                    <span class="n">Descriptor</span><span class="o">.</span><span class="n">from_str</span><span class="p">,</span>
                    <span class="n">raw_content</span><span class="p">,</span>
                    <span class="n">document_handler</span><span class="o">=</span><span class="n">DocumentHandler</span><span class="o">.</span><span class="n">DOCUMENT</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="c1"># TODO: Move the file we tried to open into some area for later</span>
        <span class="c1"># inspection so that we can download this again!</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="aglob"><a class="viewcode-back" href="../../archive.html#bushel.archive.aglob">[docs]</a><span class="k">async</span> <span class="k">def</span> <span class="nf">aglob</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :py:mod:`asyncio` wrapper for :py:func:`glob.glob`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">))</span></div>


<div class="viewcode-block" id="collector_422_filename"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_422_filename">[docs]</a><span class="k">def</span> <span class="nf">collector_422_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a filename for a bridge status according to §4.2.2 of the</span>
<span class="sd">    [collector-protocol]_. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; fingerprint = &quot;BA44A889E64B93FAA2B114E02C2A279A8555C533&quot; # Serge</span>
<span class="sd">    &gt;&gt;&gt; collector_422_filename(valid_after, fingerprint)</span>
<span class="sd">    &#39;20181119-150000-BA44A889E64B93FAA2B114E02C2A279A8555C533&#39;</span>

<span class="sd">    :param ~datetime.datetime valid_after: The valid-after time.</span>
<span class="sd">    :param str fingerprint: The fingerprint of the bridge authority.</span>

<span class="sd">    :returns: Filename as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fingerprint</span> <span class="o">=</span> <span class="n">fingerprint</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}{valid_after.month:02d}</span><span class="s2">&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">-</span><span class="si">{valid_after.hour:02d}</span><span class="s2">&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.minute:02d}{valid_after.second:02d}</span><span class="s2">&quot;</span>
            <span class="n">f</span><span class="s2">&quot;-</span><span class="si">{fingerprint}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_431_filename"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_431_filename">[docs]</a><span class="k">def</span> <span class="nf">collector_431_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a filename for a network status consensus according to §4.3.1 of the</span>
<span class="sd">    [collector-protocol]_. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; collector_431_filename(valid_after)</span>
<span class="sd">    &#39;2018-11-19-15-00-00-consensus&#39;</span>

<span class="sd">    :param ~datetime.datetime valid_after: The valid-after time.</span>

<span class="sd">    :returns: Filename as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}</span><span class="s2">-</span><span class="si">{valid_after.month:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">-</span><span class="si">{valid_after.hour:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.minute:02d}</span><span class="s2">-</span><span class="si">{valid_after.second:02d}</span><span class="s2">-consensus&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_433_filename"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_433_filename">[docs]</a><span class="k">def</span> <span class="nf">collector_433_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a filename for a network status vote according to §4.3.3 of the</span>
<span class="sd">    [collector-protocol]_.</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; v3ident = &quot;D586D18309DED4CD6D57C18FDB97EFA96D330566&quot;  # moria1</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;663B503182575D242B9D8A67334365FF8ECB53BB&quot;</span>
<span class="sd">    &gt;&gt;&gt; collector_433_filename(valid_after, v3ident, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;2018-11-19-15-00-00-vote-D586D18309DED4CD6D57C18FDB97EFA96D330566-663B...3BB&#39;</span>

<span class="sd">    Paths in the Collector File Structure Protocol using this filename expect</span>
<span class="sd">    *upper-case* hex-encoded SHA-1 digests.</span>

<span class="sd">    &gt;&gt;&gt; v3ident = &quot;d586d18309ded4cd6d57c18fdb97efa96d330566&quot;  # Lower case gets corrected</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;663b503182575d242b9d8a67334365ff8ecb53bb&quot;  # Lower case gets corrected</span>
<span class="sd">    &gt;&gt;&gt; collector_433_filename(valid_after, v3ident, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;2018-11-19-15-00-00-vote-D586D18309DED4CD6D57C18FDB97EFA96D330566-663B...3BB&#39;</span>

<span class="sd">    :param ~datetime.datetime valid_after: The valid-after time.</span>
<span class="sd">    :param str v3ident: The v3ident of the directory authority.</span>
<span class="sd">    :param str digest: The digest of the vote.</span>

<span class="sd">    :returns: Filename as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v3ident</span> <span class="o">=</span> <span class="n">v3ident</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}</span><span class="s2">-</span><span class="si">{valid_after.month:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">-</span><span class="si">{valid_after.hour:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.minute:02d}</span><span class="s2">-</span><span class="si">{valid_after.second:02d}</span><span class="s2">-vote-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{v3ident}</span><span class="s2">-</span><span class="si">{digest}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_434_filename"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_434_filename">[docs]</a><span class="k">def</span> <span class="nf">collector_434_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a filename for a microdesc-flavoured network status consensus</span>
<span class="sd">    according to §4.3.4 of the [collector-protocol]_. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; collector_434_filename(valid_after)</span>
<span class="sd">    &#39;2018-11-19-15-00-00-consensus-microdesc&#39;</span>

<span class="sd">    :param ~datetime.datetime valid_after: The valid-after time.</span>

<span class="sd">    :returns: Filename as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}</span><span class="s2">-</span><span class="si">{valid_after.month:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">-</span><span class="si">{valid_after.hour:02d}</span><span class="s2">-&quot;</span>
            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.minute:02d}</span><span class="s2">-</span><span class="si">{valid_after.second:02d}</span><span class="s2">-consensus-&quot;</span>
            <span class="s2">&quot;microdesc&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_521_substructure"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_521_substructure">[docs]</a><span class="k">def</span> <span class="nf">collector_521_substructure</span><span class="p">(</span><span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path substructure according to §5.2.1 of the</span>
<span class="sd">    [collector-protocol]_. This is used for server-descriptors and extra-info</span>
<span class="sd">    descriptors for both relays and bridges. For example:</span>

<span class="sd">    &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 9, 17, 56)</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">    &gt;&gt;&gt; collector_521_substructure(published, digest)</span>
<span class="sd">    &#39;2018/11/a/9&#39;</span>

<span class="sd">    Paths in the Collector File Structure Protocol using this substructure</span>
<span class="sd">    expect *lower-case* hex-encoded SHA-1 digests.</span>

<span class="sd">    &gt;&gt;&gt; digest = &quot;A94A07B201598D847105AE5FCD5BC3AB10124389&quot; # Upper case gets corrected</span>
<span class="sd">    &gt;&gt;&gt; collector_521_substructure(published, digest)</span>
<span class="sd">    &#39;2018/11/a/9&#39;</span>

<span class="sd">    :param ~datetime.datetime published: The published time.</span>
<span class="sd">    :param str digest: The hex-encoded SHA-1 digest for the descriptor. The</span>
<span class="sd">                       case will automatically be fixed to lower-case.</span>

<span class="sd">    :returns: Path substructure as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{published.year}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{published.month:02d}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest[0]}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest[1]}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_521_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_521_path">[docs]</a><span class="k">def</span> <span class="nf">collector_521_path</span><span class="p">(</span><span class="n">subdirectory</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path according to §5.2.1 of the [collector-protocol]_. This is</span>
<span class="sd">    used for server-descriptors and extra-info descriptors for both relays and</span>
<span class="sd">    bridges. For example:</span>

<span class="sd">    &gt;&gt;&gt; subdirectory = CollectorOutSubdirectory.RELAY_DESCRIPTORS</span>
<span class="sd">    &gt;&gt;&gt; marker = CollectorOutRelayDescsMarker.SERVER_DESCRIPTOR</span>
<span class="sd">    &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 9, 17, 56)</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">    &gt;&gt;&gt; collector_521_path(subdirectory, marker, published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;relay-descriptors/server-descriptor/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">    Paths in the Collector File Structure Protocol using this substructure</span>
<span class="sd">    expect *lower-case* hex-encoded SHA-1 digests.</span>

<span class="sd">    &gt;&gt;&gt; digest = &quot;A94A07B201598D847105AE5FCD5BC3AB10124389&quot; # Upper case gets corrected</span>
<span class="sd">    &gt;&gt;&gt; collector_521_path(subdirectory, marker, published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;relay-descriptors/server-descriptor/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">    :param str subdirectory: The subdirectory under the &quot;out&quot; directory to</span>
<span class="sd">                             use. Standard values can be found in</span>
<span class="sd">                             :py:data:`CollectorOutSubdirectory`.</span>
<span class="sd">    :param str marker: The marker under the subdirectory to use. Standard values</span>
<span class="sd">                       can be found in :py:data:`CollectorOutRelayDescsMarker`</span>
<span class="sd">                       and :py:data:`CollectorOutBridgeDescsMarker`.</span>
<span class="sd">    :param ~datetime.datetime published: The published time.</span>
<span class="sd">    :param str digest: The hex-encoded SHA-1 digest for the descriptor. The</span>
<span class="sd">                       case will automatically be fixed to lower-case.</span>

<span class="sd">    :returns: Path for the descriptor as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirectory</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">marker</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">collector_521_substructure</span><span class="p">(</span><span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">),</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_522_substructure"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_522_substructure">[docs]</a><span class="k">def</span> <span class="nf">collector_522_substructure</span><span class="p">(</span><span class="n">valid_after</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path substructure according to §5.2.2 of the</span>
<span class="sd">    [collector-protocol]_. This is used for bridge statuses, and network-status</span>
<span class="sd">    consensuses and votes. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; collector_522_substructure(valid_after)</span>
<span class="sd">    &#39;2018/11/19&#39;</span>

<span class="sd">    :param ~datetime.datetime valid_after: The valid-after time.</span>

<span class="sd">    :returns: Path substructure as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.month:02d}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_522_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_522_path">[docs]</a><span class="k">def</span> <span class="nf">collector_522_path</span><span class="p">(</span><span class="n">subdirectory</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path according to §5.2.2 of the [collector-protocol]_. This is</span>
<span class="sd">    used for bridge statuses, and network-status consensuses (both ns- and</span>
<span class="sd">    microdesc- flavors) and votes. For a bridge status for example:</span>

<span class="sd">    &gt;&gt;&gt; subdirectory = CollectorOutSubdirectory.BRIDGE_DESCRIPTORS</span>
<span class="sd">    &gt;&gt;&gt; marker = CollectorOutBridgeDescsMarker.STATUSES</span>
<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; fingerprint = &quot;BA44A889E64B93FAA2B114E02C2A279A8555C533&quot; # Serge</span>
<span class="sd">    &gt;&gt;&gt; filename = collector_422_filename(valid_after, fingerprint)</span>
<span class="sd">    &gt;&gt;&gt; collector_522_path(subdirectory, marker, valid_after, filename)  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;bridge-descriptors/statuses/2018/11/19/20181119-150000-BA44...533&#39;</span>

<span class="sd">    Or alternatively for a network-status consensus:</span>

<span class="sd">    &gt;&gt;&gt; subdirectory = CollectorOutSubdirectory.RELAY_DESCRIPTORS</span>
<span class="sd">    &gt;&gt;&gt; marker = CollectorOutRelayDescsMarker.CONSENSUS</span>
<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; filename = collector_431_filename(valid_after)</span>
<span class="sd">    &gt;&gt;&gt; collector_522_path(subdirectory, marker, valid_after, filename)</span>
<span class="sd">    &#39;relay-descriptors/consensus/2018/11/19/2018-11-19-15-00-00-consensus&#39;</span>

<span class="sd">    :param str subdirectory: The subdirectory under the &quot;out&quot; directory to</span>
<span class="sd">                             use. Standard values can be found in</span>
<span class="sd">                             :py:data:`CollectorOutSubdirectory`.</span>
<span class="sd">    :param str marker: The marker under the subdirectory to use. Standard values</span>
<span class="sd">                       can be found in :py:data:`CollectorOutRelayDescsMarker`</span>
<span class="sd">                       and :py:data:`CollectorOutBridgeDescsMarker`.</span>
<span class="sd">    :param ~datetime.datetime valid_after: The valid_after time.</span>
<span class="sd">    :param str filename: The filename to use as a :py:class:`str`, typically</span>
<span class="sd">                         created with :py:func:`collector_422_filename` for</span>
<span class="sd">                         bridge statuses, :py:func:`collector_431_filename` for</span>
<span class="sd">                         network-status consensuses, or</span>
<span class="sd">                         :py:func:`collector_433_filename` for network-status</span>
<span class="sd">                         votes.</span>

<span class="sd">    :returns: Path for the descriptor as a :py:class:`str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdirectory</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">marker</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">collector_522_substructure</span><span class="p">(</span><span class="n">valid_after</span><span class="p">),</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_533_substructure"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_533_substructure">[docs]</a><span class="k">def</span> <span class="nf">collector_533_substructure</span><span class="p">(</span><span class="n">valid_after</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a substructure according to §5.3.3 of the [collector-protocol]_.</span>
<span class="sd">    This is used for microdesc-flavored consensuses and microdescriptors. For</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; collector_533_substructure(valid_after)</span>
<span class="sd">    &#39;2018/11&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.year}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.month:02d}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="collector_534_consensus_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_534_consensus_path">[docs]</a><span class="k">def</span> <span class="nf">collector_534_consensus_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path according to §5.3.4 of the [collector-protocol]_ for a</span>
<span class="sd">    **microdesc-flavored** consensus. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; collector_534_consensus_path(valid_after)</span>
<span class="sd">    &#39;relay-descriptors/microdesc/2018/11/consensus-microdesc/19/2018-11-19-15-00-00-consensus-microdesc&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">MICRODESC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">collector_533_substructure</span><span class="p">(</span><span class="n">valid_after</span><span class="p">),</span>
                        <span class="s2">&quot;consensus-microdesc&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{valid_after.day:02d}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">collector_434_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">))</span></div>


<div class="viewcode-block" id="collector_534_microdescriptor_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.collector_534_microdescriptor_path">[docs]</a><span class="k">def</span> <span class="nf">collector_534_microdescriptor_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a path according to §5.3.4 of the [collector-protocol]_ for a</span>
<span class="sd">    microdescriptor. For example:</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;00d91cf96321fbd536dd07e297a5e1b7e6961ddd10facdd719716e351453168f&quot;</span>
<span class="sd">    &gt;&gt;&gt; collector_534_microdescriptor_path(valid_after, digest)</span>
<span class="sd">    &#39;relay-descriptors/microdesc/2018/11/micro/0/0/00d91cf96321fbd536dd07e297a5e1b7e6961ddd10facdd719716e351453168f&#39;</span>

<span class="sd">    This path in the Collector File Structure Protocol using this substructure</span>
<span class="sd">    expect *lower-case* hex-encoded SHA-256 digests.</span>

<span class="sd">    &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">    &gt;&gt;&gt; digest = &quot;00D91CF96321FBD536DD07E297A5E1B7E6961DDD10FACDD719716E351453168F&quot;</span>
<span class="sd">    &gt;&gt;&gt; collector_534_microdescriptor_path(valid_after, digest)</span>
<span class="sd">    &#39;relay-descriptors/microdesc/2018/11/micro/0/0/00d91cf96321fbd536dd07e297a5e1b7e6961ddd10facdd719716e351453168f&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">digest</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">MICRODESC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">collector_533_substructure</span><span class="p">(</span><span class="n">valid_after</span><span class="p">),</span> <span class="s2">&quot;micro&quot;</span><span class="p">,</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest[0]}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest[1]}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{digest}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="prepare_annotated_content"><a class="viewcode-back" href="../../archive.html#bushel.archive.prepare_annotated_content">[docs]</a><span class="k">def</span> <span class="nf">prepare_annotated_content</span><span class="p">(</span><span class="n">descriptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encodes annotations and prepends them to the descriptor bytes for writing</span>
<span class="sd">    to disk.</span>

<span class="sd">    :param ~stem.descriptor.Descriptor descriptor: The descriptor to prepare.</span>

<span class="sd">    :returns: :py:class:`bytes` for the annotated descriptor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">get_bytes</span><span class="p">()</span>
    <span class="n">type_annotation</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">type_annotation</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">type_annotation</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">content</span></div>


<div class="viewcode-block" id="valid_after_now"><a class="viewcode-back" href="../../archive.html#bushel.archive.valid_after_now">[docs]</a><span class="k">def</span> <span class="nf">valid_after_now</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a good guess at the valid-after time of the latest consensus. There</span>
<span class="sd">    is an assumption that there is a new consensus every hour and that it is</span>
<span class="sd">    valid from the top of the hour. Different valid-after times are compliant</span>
<span class="sd">    with [dir-spec]_ however, and so this may be wrong.</span>

<span class="sd">    :returns: A :py:class:`~datetime.datetime` for the top of the hour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">valid_after</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">valid_after</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="DirectoryArchive"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive">[docs]</a><span class="k">class</span> <span class="nc">DirectoryArchive</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Persistent filesystem-backed archive for Tor directory protocol</span>
<span class="sd">    descriptors.</span>

<span class="sd">    This implements the CollecTor File Structure Protocol as detailed in</span>
<span class="sd">    [collector-protocol]_.</span>

<span class="sd">    :param str archive_path: Either an absolute or relative path to the</span>
<span class="sd">                             location of the directory to use for the archive.</span>
<span class="sd">                             This location must exist, but may be an empty</span>
<span class="sd">                             directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">archive_path</span><span class="p">,</span>
                 <span class="n">max_file_concurrency</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">archive_path</span> <span class="o">=</span> <span class="n">archive_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">BoundedSemaphore</span><span class="p">(</span>
            <span class="n">max_file_concurrency</span><span class="p">)</span>

    <span class="c1">####################</span>
    <span class="c1"># out/ Paths       #</span>
    <span class="c1">####################</span>

<div class="viewcode-block" id="DirectoryArchive.path_for"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.path_for">[docs]</a>    <span class="k">def</span> <span class="nf">path_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">create_dir</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The filesystem path that a descriptor will be archived at. These paths</span>
<span class="sd">        are defined in [collector-protocol]_.</span>

<span class="sd">        It is also possible to set *descriptor* with a :py:class:`str` in</span>
<span class="sd">        which case it will be treated as a relative path from the root of the</span>
<span class="sd">        archive. For example:</span>

<span class="sd">        &gt;&gt;&gt; DirectoryArchive(&quot;/srv/archive&quot;).path_for(&quot;path/to/descriptor&quot;)</span>
<span class="sd">        &#39;/srv/archive/path/to/descriptor&#39;</span>

<span class="sd">        :param bool create_dir: Create the directory ready to archive a</span>
<span class="sd">                                descriptor.</span>

<span class="sd">        :returns: Archive path for the descriptor as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">archive_path</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">BridgeDescriptor</span><span class="p">):</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bridge_server_descriptor_path</span><span class="p">(</span><span class="n">descriptor</span><span class="o">.</span><span class="n">published</span><span class="p">,</span>
                                                       <span class="n">descriptor</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">BridgeExtraInfoDescriptor</span><span class="p">):</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bridge_extra_info_descriptor_path</span><span class="p">(</span>
                <span class="n">descriptor</span><span class="o">.</span><span class="n">published</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">RelayDescriptor</span><span class="p">):</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_server_descriptor_path</span><span class="p">(</span><span class="n">descriptor</span><span class="o">.</span><span class="n">published</span><span class="p">,</span>
                                                      <span class="n">descriptor</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">RelayExtraInfoDescriptor</span><span class="p">):</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_extra_info_descriptor_path</span><span class="p">(</span>
                <span class="n">descriptor</span><span class="o">.</span><span class="n">published</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">Microdescriptor</span><span class="p">):</span>
            <span class="c1"># TODO: With better annotations support in stem we can keep the</span>
            <span class="c1"># metadata around for the valid_after date.</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_microdescriptor_path</span><span class="p">(</span><span class="n">valid_after_now</span><span class="p">(),</span>
                                                    <span class="n">descriptor</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">NetworkStatusDocumentV3</span><span class="p">)</span> <span class="ow">and</span> \
              <span class="n">descriptor</span><span class="o">.</span><span class="n">is_consensus</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">descriptor</span><span class="o">.</span><span class="n">is_microdescriptor</span><span class="p">:</span>
                <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_microdescriptor_consensus_path</span><span class="p">(</span>
                    <span class="n">descriptor</span><span class="o">.</span><span class="n">valid_after</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_consensus_path</span><span class="p">(</span><span class="n">descriptor</span><span class="o">.</span><span class="n">valid_after</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">NetworkStatusDocumentV3</span><span class="p">)</span> <span class="ow">and</span> \
              <span class="n">descriptor</span><span class="o">.</span><span class="n">is_vote</span><span class="p">:</span>
            <span class="c1"># TODO: The digest functionality should be appearing in stem.</span>
            <span class="c1"># https://trac.torproject.org/projects/tor/ticket/28398</span>
            <span class="n">raw_content</span><span class="p">,</span> <span class="n">ending</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">descriptor</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">directory-signature &quot;</span>
            <span class="n">raw_content</span> <span class="o">=</span> <span class="n">raw_content</span><span class="p">[:</span><span class="n">raw_content</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">ending</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ending</span><span class="p">)]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="n">digest</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">raw_content</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_vote_path</span><span class="p">(</span>
                <span class="n">descriptor</span><span class="o">.</span><span class="n">valid_after</span><span class="p">,</span>
                <span class="n">descriptor</span><span class="o">.</span><span class="n">directory_authorities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">descriptor</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Attempted to store unknown descriptor type {type(descriptor)}&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">create_dir</span><span class="p">:</span>
            <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpath</span></div>

<div class="viewcode-block" id="DirectoryArchive.bridge_server_descriptor_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.bridge_server_descriptor_path">[docs]</a>    <span class="k">def</span> <span class="nf">bridge_server_descriptor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a bridge server</span>
<span class="sd">        descriptor with a given published time and digest. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 15, 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">        &gt;&gt;&gt; archive.bridge_server_descriptor_path(published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/bridge-descriptors/server-descriptor/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">        These paths are defined in §5.2.1 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime published: The published time of the</span>
<span class="sd">                                             descriptor.</span>
<span class="sd">        :param str digest: The hex-encoded SHA-1 digest of the descriptor.</span>

<span class="sd">        :returns: Archive path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_521_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">BRIDGE_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">SERVER_DESCRIPTOR</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">published</span><span class="p">,</span>
                <span class="n">digest</span><span class="p">))</span></div>

<div class="viewcode-block" id="DirectoryArchive.bridge_extra_info_descriptor_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.bridge_extra_info_descriptor_path">[docs]</a>    <span class="k">def</span> <span class="nf">bridge_extra_info_descriptor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a bridge extra-info</span>
<span class="sd">        descriptor with a given published time and digest. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 9, 17, 56)</span>
<span class="sd">        &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">        &gt;&gt;&gt; archive.bridge_extra_info_descriptor_path(published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/bridge-descriptors/extra-info/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">        These paths are defined in §5.2.1 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime published: The published time of the</span>
<span class="sd">                                             descriptor.</span>
<span class="sd">        :param str digest: The hex-encoded SHA-1 digest of the descriptor.</span>

<span class="sd">        :returns: Archive path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_521_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">BRIDGE_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">published</span><span class="p">,</span>
                <span class="n">digest</span><span class="p">))</span></div>

<div class="viewcode-block" id="DirectoryArchive.bridge_status_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.bridge_status_path">[docs]</a>    <span class="k">def</span> <span class="nf">bridge_status_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a bridge status</span>
<span class="sd">        valid-after time and generated by the authority with the given</span>
<span class="sd">        fingerprint. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">        &gt;&gt;&gt; fingerprint = &quot;BA44A889E64B93FAA2B114E02C2A279A8555C533&quot;  # Serge</span>
<span class="sd">        &gt;&gt;&gt; archive.bridge_status_path(valid_after, fingerprint)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/bridge-descriptors/statuses/2018/11/19/20181119-150000-BA...33&#39;</span>

<span class="sd">        These paths are defined in §5.2.2 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime valid_after: The valid-after time for the</span>
<span class="sd">                                               status.</span>
<span class="sd">        :param str fingerprint: The fingerprint of the bridge authority.</span>

<span class="sd">        :returns: Path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_522_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">BRIDGE_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutBridgeDescsMarker</span><span class="o">.</span><span class="n">STATUSES</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">valid_after</span><span class="p">,</span>
                <span class="n">collector_422_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_server_descriptor_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_server_descriptor_path">[docs]</a>    <span class="k">def</span> <span class="nf">relay_server_descriptor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a relay server</span>
<span class="sd">        descriptor with a given published time and digest. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 15, 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">        &gt;&gt;&gt; archive.relay_server_descriptor_path(published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/relay-descriptors/server-descriptor/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">        These paths are defined in §5.3.2 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime published: The published time of the</span>
<span class="sd">                                             descriptor.</span>
<span class="sd">        :param str digest: The hex-encoded SHA-1 digest of the descriptor.</span>

<span class="sd">        :returns: Path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_521_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">SERVER_DESCRIPTOR</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">published</span><span class="p">,</span>
                <span class="n">digest</span><span class="p">))</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_extra_info_descriptor_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_extra_info_descriptor_path">[docs]</a>    <span class="k">def</span> <span class="nf">relay_extra_info_descriptor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">published</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a relay extra-info</span>
<span class="sd">        descriptor with a given published time and digest. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; published = datetime.datetime(2018, 11, 19, 9, 17, 56)</span>
<span class="sd">        &gt;&gt;&gt; digest = &quot;a94a07b201598d847105ae5fcd5bc3ab10124389&quot;</span>
<span class="sd">        &gt;&gt;&gt; archive.relay_extra_info_descriptor_path(published, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/relay-descriptors/extra-info/2018/11/a/9/a94a...389&#39;</span>

<span class="sd">        These paths are defined in §5.3.2 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime published: The published time of the</span>
<span class="sd">                                             descriptor.</span>
<span class="sd">        :param str digest: The hex-encoded SHA-1 digest of the descriptor.</span>

<span class="sd">        :returns: Path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_521_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">EXTRA_INFO</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">published</span><span class="p">,</span>
                <span class="n">digest</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">relay_microdescriptor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="n">digest_bytes</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="n">digest_bytes</span> <span class="o">+=</span> <span class="sa">b</span><span class="s1">&#39;=&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digest_bytes</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">digest</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">decodebytes</span><span class="p">(</span><span class="n">digest_bytes</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_534_microdescriptor_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">digest</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">relay_microdescriptor_consensus_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span><span class="n">collector_534_consensus_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">))</span>

<div class="viewcode-block" id="DirectoryArchive.relay_consensus_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_consensus_path">[docs]</a>    <span class="k">def</span> <span class="nf">relay_consensus_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a network-status</span>
<span class="sd">        consensus with a given valid-after time. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">        &gt;&gt;&gt; archive.relay_consensus_path(valid_after)</span>
<span class="sd">        &#39;/srv/archive/relay-descriptors/consensus/2018/11/19/2018-11-19-15-00-00-consensus&#39;</span>

<span class="sd">        These paths are defined in §5.3.2 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime valid_after: The valid-after time for the</span>
<span class="sd">                                               status.</span>
<span class="sd">        :param str fingerprint: The fingerprint of the bridge authority.</span>

<span class="sd">        :returns: Path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_522_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">CONSENSUS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">valid_after</span><span class="p">,</span>
                <span class="n">collector_431_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_vote_path"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_vote_path">[docs]</a>    <span class="k">def</span> <span class="nf">relay_vote_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_after</span><span class="p">,</span> <span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path, including the archive path, for a network-status vote</span>
<span class="sd">        with a given valid-after time, generated by the authority with the</span>
<span class="sd">        given v3ident, and with the given digest. For example:</span>

<span class="sd">        &gt;&gt;&gt; archive = DirectoryArchive(&quot;/srv/archive&quot;)</span>
<span class="sd">        &gt;&gt;&gt; valid_after = datetime.datetime(2018, 11, 19, 15)</span>
<span class="sd">        &gt;&gt;&gt; v3ident = &quot;D586D18309DED4CD6D57C18FDB97EFA96D330566&quot;  # moria1</span>
<span class="sd">        &gt;&gt;&gt; digest = &quot;663B503182575D242B9D8A67334365FF8ECB53BB&quot;</span>
<span class="sd">        &gt;&gt;&gt; archive.relay_vote_path(valid_after, v3ident, digest)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;/srv/archive/relay-descriptors/vote/2018/11/19/2018-11-19-15-00-00-vote-D...-...B&#39;</span>

<span class="sd">        These paths are defined in §5.3.2 of [collector-protocol]_.</span>

<span class="sd">        :param ~datetime.datetime valid_after: The valid-after time.</span>
<span class="sd">        :param str v3ident: The v3ident of the directory authority.</span>
<span class="sd">        :param str digest: The digest of the vote.</span>

<span class="sd">        :returns: Path as a :py:class:`str`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span>
            <span class="n">collector_522_path</span><span class="p">(</span>
                <span class="n">CollectorOutSubdirectory</span><span class="o">.</span><span class="n">RELAY_DESCRIPTORS</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">CollectorOutRelayDescsMarker</span><span class="o">.</span><span class="n">VOTE</span><span class="p">,</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="n">valid_after</span><span class="p">,</span>
                <span class="n">collector_433_filename</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="p">)))</span></div>

    <span class="c1">####################</span>
    <span class="c1"># Store Descriptor #</span>
    <span class="c1">####################</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_for</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">create_dir</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Saving: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">aiofiles</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prepare_annotated_content</span><span class="p">(</span><span class="n">descriptor</span><span class="p">))</span>

    <span class="c1">####################</span>
    <span class="c1"># Get Descriptor   #</span>
    <span class="c1">####################</span>

<div class="viewcode-block" id="DirectoryArchive.relay_server_descriptor"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_server_descriptor">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_server_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a relay&#39;s server descriptor from the archive.</span>

<span class="sd">        :param str digest: A hex-encoded digest of the descriptor.</span>
<span class="sd">        :param ~datetime.datetime published_hint: Provides a hint on the</span>
<span class="sd">            published time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor was not published in the same month as this, it</span>
<span class="sd">            will not be found.</span>

<span class="sd">        :returns: A :py:class:`stem.descriptor.server_descriptor.RelayDescriptor`</span>
<span class="sd">                  if found, otherwise *None*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">published_hint</span> <span class="o">=</span> <span class="n">published_hint</span> <span class="ow">or</span> <span class="n">valid_after_now</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_server_descriptor_path</span><span class="p">(</span><span class="n">published_hint</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">parse_file</span><span class="p">(</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">descriptor_type</span><span class="o">=</span><span class="s2">&quot;server-descriptor 1.0&quot;</span><span class="p">)</span></div>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_multiple_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single_descriptor_function</span><span class="p">,</span> <span class="n">digests</span><span class="p">,</span>
                                    <span class="n">published_hint</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">descriptor</span> <span class="k">for</span> <span class="n">descriptor</span> <span class="ow">in</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">single_descriptor_function</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">digest</span> <span class="ow">in</span> <span class="n">digests</span>
            <span class="p">])</span> <span class="k">if</span> <span class="n">descriptor</span>
        <span class="p">]</span>

<div class="viewcode-block" id="DirectoryArchive.relay_server_descriptors"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_server_descriptors">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_server_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digests</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves multiple server descriptors published around the same time</span>
<span class="sd">        (e.g. all referenced by the same consensus).</span>

<span class="sd">        :param list(str) digest: Hex-encoded digests for the descriptors.</span>
<span class="sd">        :param ~datetime.datetime published_hint: Provides a hint on the</span>
<span class="sd">            published time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor was not published in the same month as this, it</span>
<span class="sd">            will not be found.</span>

<span class="sd">        :returns: A :py:class:`list` of</span>
<span class="sd">                  :py:class:`stem.descriptor.server_descriptor.RelayDescriptor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiple_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relay_server_descriptor</span><span class="p">,</span>
                                                <span class="n">digests</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_microdescriptor"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_microdescriptor">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_microdescriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">valid_after_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a relay&#39;s microdescriptor from the archive.</span>

<span class="sd">        :param str digest: A hex-encoded digest of the descriptor.</span>
<span class="sd">        :param ~datetime.datetime valid_after_hint: Provides a hint on the</span>
<span class="sd">            valid_after time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor did not become valid in the same month as this,</span>
<span class="sd">            it will not be found.</span>

<span class="sd">        :returns: A :py:class:`stem.descriptor.microdescriptor.Microdescriptor`</span>
<span class="sd">                  if found, otherwise *None*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_after_hint</span> <span class="o">=</span> <span class="n">valid_after_hint</span> <span class="ow">or</span> <span class="n">valid_after_now</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_microdescriptor_path</span><span class="p">(</span><span class="n">valid_after_hint</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">parse_file</span><span class="p">(</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">descriptor_type</span><span class="o">=</span><span class="s2">&quot;microdescriptor 1.0&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_microdescriptors"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_microdescriptors">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_microdescriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digests</span><span class="p">,</span> <span class="n">valid_after_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves multiple microdescriptors around the same valid_after time</span>
<span class="sd">        (e.g. all referenced by the same microdescriptor consensus).</span>

<span class="sd">        :param list(str) digest: Hex-encoded digests for the descriptors.</span>

<span class="sd">        :param ~datetime.datetime valid_after_hint: Provides a hint on the</span>
<span class="sd">            valid_after time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor did not become valid in the same month as this,</span>
<span class="sd">            it will not be found.</span>

<span class="sd">        :returns: A :py:class:`list` of</span>
<span class="sd">                  :py:class:`stem.descriptor.microdescriptor.Microdescriptor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiple_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relay_microdescriptor</span><span class="p">,</span>
                                                <span class="n">digests</span><span class="p">,</span> <span class="n">valid_after_hint</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_extra_info_descriptor"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_extra_info_descriptor">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_extra_info_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a relay&#39;s extra-info descriptor from the archive.</span>

<span class="sd">        :param str digest: A hex-encoded digest of the descriptor.</span>
<span class="sd">        :param ~datetime.datetime published_hint: Provides a hint on the</span>
<span class="sd">            published time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor was not published in the same month as this, it</span>
<span class="sd">            will not be found.</span>

<span class="sd">        :returns: A :py:class:`~stem.descriptor.extrainfo_descriptor.RelayExtraInfoDescriptor`</span>
<span class="sd">                  if found, otherwise *None*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">published_hint</span> <span class="o">=</span> <span class="n">published_hint</span> <span class="ow">or</span> <span class="n">valid_after_now</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_extra_info_descriptor_path</span><span class="p">(</span><span class="n">published_hint</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">parse_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">descriptor_type</span><span class="o">=</span><span class="s2">&quot;extra-info 1.0&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_extra_info_descriptors"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_extra_info_descriptors">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_extra_info_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digests</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves multiple extra-info descriptors published around the same time</span>
<span class="sd">        (e.g. all referenced by server-descriptors in the same consensus).</span>

<span class="sd">        :param list(str) digest: Hex-encoded digests for the descriptors.</span>
<span class="sd">        :param ~datetime.datetime published_hint: Provides a hint on the</span>
<span class="sd">            published time to allow the descriptor to be found in the archive.</span>
<span class="sd">            If the descriptor was not published in the same month as this, it</span>
<span class="sd">            will not be found.</span>

<span class="sd">        :returns: A :py:class:`list` of</span>
<span class="sd">                  :py:class:`stem.descriptor.extrainfo_descriptor.RelayExtraInfoDescriptor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiple_descriptors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relay_extra_info_descriptor</span><span class="p">,</span> <span class="n">digests</span><span class="p">,</span> <span class="n">published_hint</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_vote"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_vote">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_vote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">valid_after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a vote from the archive.</span>

<span class="sd">        :param str v3ident: The v3ident of the authority that created the vote.</span>
<span class="sd">        :param str digest: A hex-encoded digest of the vote. This will</span>
<span class="sd">                           automatically be fixed to upper-case.</span>
<span class="sd">        :param ~datetime.datetime valid_after: If set, will retrieve a</span>
<span class="sd">            consensus with the given valid_after time, otherwise a vote that</span>
<span class="sd">            became valid at the top of the current hour will be retrieved.</span>

<span class="sd">        :returns: A :py:class:`~stem.descriptor.networkstatus.NetworkStatusDocumentV3`</span>
<span class="sd">                  if found, otherwise *None*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_after</span> <span class="o">=</span> <span class="n">valid_after</span> <span class="ow">or</span> <span class="n">valid_after_now</span><span class="p">()</span>
        <span class="n">digest</span> <span class="o">=</span> <span class="n">digest</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_vote_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">,</span> <span class="n">v3ident</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">digest</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="n">aglob</span><span class="p">(</span><span class="n">path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">parse_file</span><span class="p">(</span>
                <span class="n">path</span><span class="p">,</span> <span class="n">descriptor_type</span><span class="o">=</span><span class="s2">&quot;network-status-vote-3 1.0&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DirectoryArchive.relay_consensus"><a class="viewcode-back" href="../../archive.html#bushel.archive.DirectoryArchive.relay_consensus">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">relay_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="s2">&quot;ns&quot;</span><span class="p">,</span> <span class="n">valid_after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a consensus from the archive.</span>

<span class="sd">        :param ~datetime.datetime valid_after: If set, will retrieve a consensus with the</span>
<span class="sd">                                     given valid_after time, otherwise a vote</span>
<span class="sd">                                     that became valid at the top of the</span>
<span class="sd">                                     current hour will be retrieved.</span>

<span class="sd">        :returns: A :py:class:`~stem.descriptor.network_status.NetworkStatusDocumentV3`</span>
<span class="sd">                  if found, otherwise *None*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_after</span> <span class="o">=</span> <span class="n">valid_after</span> <span class="ow">or</span> <span class="n">valid_after_now</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">flavor</span> <span class="o">==</span> <span class="s2">&quot;microdesc&quot;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_microdescriptor_consensus_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># probably we want &quot;ns&quot;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relay_consensus_path</span><span class="p">(</span><span class="n">valid_after</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_file_concurrency_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">parse_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">bushel</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../archive.html">Directory Archive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bandwidth.html">Bandwidth Scanner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../collector.html">CollecTor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../directory.html">Tor Directory Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloader.html">Directory Downloader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../monitoring.html">Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plugins.html">Plugin API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Tor Project.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>